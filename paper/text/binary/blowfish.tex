\subsection{Blowfish}

Blowfish --- это алгоритм, разработанный Брюсом Шнайером специально 
для реализации на больших микропроцессорах. Алгоритм Blowfish 
не запатентован.

Алгоритм Blowfish оптимизирован для применения в системах, не 
практикующих частой смены ключей, например, в линиях связи и 
программах автоматического шифрования файлов. При реализации 
на 32-битовых микропроцессорах с большим размером кэша данных
, например, процессорах Pentium и PowerPC, алгоритм Blowfish 
заметно быстрее DES.

\subsubsection{Описание шифра Blowfish}

Blowfish представляет собой 64-битовый блочный алгоритм шифрования 
с ключом переменной длины. Алгоритм состоит из двух частей: расширения 
ключа и шифрования данных. Расширение ключа преобразует ключ 
длиной до 448 битов в несколько массивов подключей общим размером 4168 байт.

Шифрование данных заключается в последовательном исполнении простой 
функции 16 раз. На каждом раунде выполняются зависимая от ключа 
перестановка и зависимая от ключа и данных подстановка. Используются 
только операции сложения и XOR над 32-битовыми словами. Единственные 
дополнительные операции каждого раунда - четыре взятия данных 
из индексированного массива.
То есть, алгоритм Blowfish представляет собой сеть Фейстеля, состоящей 
из 16 раундов. На вход подается 64-битовый элемент данных $х$.

В алгоритме Blowfish используется множество подключей. Эти подключи 
должны быть вычислены до начала зашифрования или расшифрования данных.

Подключи рассчитываются с помощью самого алгоритма Blowfish. 
Вот какова точная последовательность действий:
\begin{enumerate}
\item Сначала Р-массив, а затем четыре S-блока по порядку инициализируются 
    фиксированной строкой.
\item Выполняется операция XOR над Р1 с первыми 32 битами ключа, 
    XOR над Р2 со вторыми 32 битами ключа, и т.д. для всех битов 
    ключа (вплоть до Р18). Операция XOR выполняется циклически над 
    битами ключа до тех пор, пока весь Р-массив не будет инициализирован.
\item Используя подключи, полученные на этапах 1 и 2, алгоритм 
    Blowfish шифрует строку из одних нулей.
\item Р1 и Р2 заменяются результатом этапа 3.
\item Результат этапа 3 шифруется с помощью алгоритма Blowfish 
    и модифицированных подключей.
\item Р3 и Р4 заменяются результатом этапа 5.
\item Далее по ходу процесса все элементы Р-массива, а затем 
    все четыре S-блока по порядку заменяются выходом постоянно меняющегося 
    алгоритма Blowfish.
\end{enumerate}

Всего для генерации всех необходимых подключей требуется 521 
итерация. Приложения могут сохранять подключи - нет необходимости 
выполнять процесс их получения многократно.
В реализациях Blowfish, в которых требуется очень высокая скорость,
цикл должен быть развернут, а все ключи храниться в кэше.

\subsubsection{Криптоанализ, обоснование стойкости}

В курсовой работе описан криптоанализ Blowfish с уменьшенным 
количеством раундов $t$ (в оригинальном алгоритме 16 раундов) 
и без итоговой перестановки регистров в сети Фейстеля. 
Практически подтверждены границы
стойкости данные в работе \cite{vaudenay-blowfish}, а именно 
возможности с помощью дифференциального криптоанализа раскрыть 
$P$-массив с помощью $28^{t + 1}$ выбранных открытых текстов. 

Слабым является ключ, для которого 
два элемента данного $S$-блока идентичны.
Для некоторых найденных слабых ключей, которые 
генерируют плохие $S$-блоки 
(вероятность выбора такого ключа составляет 1 к 214), 
показано что это же вскрытие раскрывает 
$P$-массив с помощью всего $24^{t + 1}$. При неизвестных $S$-блоках это 
вскрытие может обнаружить использование слабого ключа, но не 
может определит сам ключ (ни $S$-блоки, ни $P$-массив).

Случаи успешного криптоанализа Blowfish не известны.
