\subsection{Blowfish}

Blowfish --- это алгоритм, разработанный Брюсом Шнайером специально 
для реализации на больших микропроцессорах. Алгоритм Blowfish 
не запатентован.

Алгоритм Blowfish оптимизирован для применения в системах, не 
практикующих частой смены ключей, например, в линиях связи и 
программах автоматического шифрования файлов. При реализации 
на 32-битовых микропроцессорах с большим размером кэша данных
, например, процессорах Pentium и PowerPC, алгоритм Blowfish 
заметно быстрее DES.

\subsubsection{Описание шифра Blowfish}

Blowfish представляет собой 64-битовый блочный алгоритм шифрования 
с ключом переменной длины. Алгоритм состоит из двух частей: расширения 
ключа и шифрования данных. Расширение ключа преобразует ключ 
длиной до 448 битов в несколько массивов подключей общим размером 4168 байт.

Шифрование данных заключается в последовательном исполнении простой 
функции 16 раз. На каждом раунде выполняются зависимая от ключа 
перестановка и зависимая от ключа и данных подстановка. Используются 
только операции сложения и XOR над 32-битовыми словами. Единственные 
дополнительные операции каждого раунда - четыре взятия данных 
из индексированного массива.
То есть, алгоритм Blowfish представляет собой сеть Фейстеля, состоящей 
из 16 раундов. На вход подается 64-битовый элемент данных $х$.

В алгоритме Blowfish используется множество подключей. Эти подключи 
должны быть вычислены до начала зашифрования или расшифрования данных.

Подключи рассчитываются с помощью самого алгоритма Blowfish. 
Вот какова точная последовательность действий:
\begin{enumerate}
\item Сначала Р-массив, а затем четыре S-блока по порядку инициализируются 
    фиксированной строкой.
\item Выполняется операция XOR над Р1 с первыми 32 битами ключа, 
    XOR над Р2 со вторыми 32 битами ключа, и т.д. для всех битов 
    ключа (вплоть до Р18). Операция XOR выполняется циклически над 
    битами ключа до тех пор, пока весь Р-массив не будет инициализирован.
\item Используя подключи, полученные на этапах 1 и 2, алгоритм 
    Blowfish шифрует строку из одних нулей.
\item Р1 и Р2 заменяются результатом этапа 3.
\item Результат этапа 3 шифруется с помощью алгоритма Blowfish 
    и модифицированных подключей.
\item Р3 и Р4 заменяются результатом этапа 5.
\item Далее по ходу процесса все элементы Р-массива, а затем 
    все четыре S-блока по порядку заменяются выходом постоянно меняющегося 
    алгоритма Blowfish.
\end{enumerate}

Всего для генерации всех необходимых подключей требуется 521 
итерация. Приложения могут сохранять подключи - нет необходимости 
выполнять процесс их получения многократно.
В реализациях Blowfish, в которых требуется очень высокая скорость,
цикл должен быть развернут, а все ключи храниться в кэше.

\subsubsection{Криптоанализ, обоснование стойкости}
Serge Vaudenay исследовал алгоритм Blowfish с известными 
$S$-блоками и $r$ раундами в работе \cite{vaudenay-blowfish}.
Дифференциальный криптоанализ может раскрыть 
$P$-массив с помощью $28^{r + 1}$ выбранных открытых текстов. Для 
некоторых слабых ключей, которые генерируют плохие $S$-блоки (вероятность 
выбора такого ключа составляет 1 к 214), это же вскрытие раскрывает 
$P$-массив с помощью всего $24^{r + 1}$. При неизвестных $S$-блоках это 
вскрытие может обнаружить использование слабого ключа, но не 
может определит сам ключ (ни $S$-блоки, ни $P$-массив). Это вскрытие 
эффективно только против вариантов с уменьшенным числом этапов 
и совершенно бесполезно против 16-этапного Blowfish.

Конечно, важно и раскрытие слабых ключей, даже хотя они скорее 
всего не будут использоваться. Слабым является ключ, для которого 
два элемента данного $S$-блока идентичны. До выполнения развертывания 
ключа невозможно определить, является ли он слабым. Если вы беспокоитесь 
об этом, вам придется выполнить развертывание ключа и проверить,
нет ли в $S$-одинаковых элементов. Хотя я не думаю, что это так 
уж необходимо.

Случаи успешного криптоанализа Blowfish не известны.
